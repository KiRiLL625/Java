import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        /*
        Мы можем также сами "выбрасывать" исключения (генерировать ошибки)
        с помощью ключевого слова throw.

        Разберём такой пример. Нам нужно, чтобы у нас делимое не было равно нулю,
        а если оно равно 0, то мы создадим арифметическую ошибку. Вообще ноль делить
        на что-то можно, но нам нужно, чтобы так делать было нельзя. Для этого мы
        используем throw.
         */

        //Считываем данные
        Scanner scanner = new Scanner(System.in);
        int a = scanner.nextInt();
        int b = scanner.nextInt();
        if(a == 0){
            //Если делимое 0, то создаём ошибку неправильного аргумента с сообщением:
            throw new IllegalArgumentException("Делимое не может быть 0!");
            /*Фактически сверху мы создали объект класса IllegalArgumentException так,
            как мы это делали в первом примере. Генерировать ошибки можно любых типов.
             */
        }
        System.out.println(a / b);
        /*
        Теперь если первое число будет 0, то вывод будет следующим:
        
        Exception in thread "main" java.lang.IllegalArgumentException: Делимое не может быть 0!
	    at Main.main(Main.java:<тут номер строки, где ошибка>)
         */

        //Проверяемые и непроверяемые исключения.
        int d1 = scanner.nextInt();
        int d2 = scanner.nextInt();
        System.out.println(d1 / d2);
        /*
        Эту ситуацию мы уже рассматривали: если 2 число будет 0, то программа
        завершится с ошибкой. При этом написав такой код, мы не увидим никаких ошибок,
        и наш код скомпилируется нормально. Это пример непроверяемых исключений - компилятор
        нас не предупреждает о возможной ошибке.

        Проверяемые исключения. Тут компилятор уже проверяет наш код и не даст нам создать
        небезопасный код, то есть наша программа просто не скомпилируется. Например, объекты
        класса FileReader просто так создать нельзя:
         */
        FileReader fd = new FileReader("MyFile.txt");
        /*
        Строка выше не скомпилируется, так как это проверяемое исключение: компилятор
        предупреждает нас, что файла MyFile.txt может не существовать.

        В таком случае надо обернуть этот код в try-catch или в методе добавить
        throws (об этом ниже):
         */
        try {
            FileReader fd1 = new FileReader("MyFile.txt");
        } catch (FileNotFoundException fnfe) {
            System.out.println("Файл не найден!");
        }
        /*
        Теперь если первый аргумент будет 0, то вывод будет следующим:
         */
    }
    /*
    Если мы хотим предупредить компилятор, что метод может выбрасывать ошибку, то
    после аргументов какого-либо метода добавляем throws и класс ошибки (без слова new,
    так как throw и throws - два разных оператора, нельзя их путать, и здесь мы не
    генерируем ошибку, а просто говорим, что она может возникнуть). В данном случае
    мы предполагаем, что второе число может быть 0 и говорим, что может быть арифметическая
    ошибка.
     */
    public static int divide(int a, int b) throws ArithmeticException{
        return a / b;
    }

    //Проверяемые исключения обязывают нас добавить в сигнатуру (определение)
    //метода throws или обернуть код в try-catch

    //Метод main (наш самый главный метод) может также содержать throws в своей сигнатуре.
    public static void readFile(String fileName) throws FileNotFoundException {
        FileReader fd = new FileReader(fileName);
    }
    
    /*
    И просто полезные фишки: если вы хотите обратить особое внимание на какой-то
    комментарий, то можно написать TODO или FIXME и тогда слова после этих слов
    станут выделены каким-то цветом (в разных средах разработки по-разному, в
    IntelliJ IDEA это оранжевый цвет)
     */

    //TODO: Доделать!
    //FIXME: Исправить!
    //fixme todo да, можно и с маленькой буквы писать
}
