import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.Scanner;

public class Main {
    /*public static void divide(int a, int b) throws ArithmeticException{
        System.out.println(a / b);
    }
     */
    public static void main(String[] args) {
        /*
        Исключения (обработка ошибок).
        Бывают такие ситуации, когда в программе возникают ошибки
        (исключения). Допустим, у нас есть программа, которая считывает
        из консоли 2 числа и выводит результат их деления:
         */
        Scanner scanner = new Scanner(System.in);
        int a = scanner.nextInt();
        int b = scanner.nextInt();
        System.out.println(a / b);
        /*
        Всё будет хорошо до тех пор, пока мы не введём вторым числом 0.
        Тогда наша программа завершится с ошибкой (выбросит исключение).
        Например, если ввести числа 2 и 0, то программа выведет следующее:

        Exception in thread "main" java.lang.ArithmeticException: / by zero
	    at Main.main(Main.java:<тут номер строки, где возникла ошибка>)

	    У нас появилась арифметическая ошибка: деление на ноль. И программа
	    завершилась, не выводя никакого результата.

        Но что же делать, если мы знаем, что такая ситуация может возникнуть, хотим
        её обработать и продолжить выполнение нашей программы без её аварийного
        завершения?

        На помощь приходит try-catch блок. Мы можем "попробовать" (try) наш код и если в нём
        возникнет ошибка, то мы сможем её "поймать" (catch):
         */
        /*Сверху мы уже объявили переменные a, b, поэтому снова объявлять их не будем,
        а просто обернём в try-catch вывод деления a на b:
         */
        try{
            System.out.println(a / b);
            /*
            Пробуем код внутри try: если он выполнится без ошибок, то программа
            пойдёт дальше, не попадая в catch
             */
        } catch(ArithmeticException ae){
            System.out.println("Делить на ноль нельзя!");
            /*
            Если блок try выполнился с ошибкой, то мы "ловим" эту ошибку
            в catch и выполняем код внутри catch. В круглых скобках написан
            тип ошибки, в нашем случае это ArithmeticException, затем идёт
            название переменной, обычно её называют по первым буквам класса ошибки,
            в нашем случае это ae. Тип ошибки можно определить, когда у нас происходит
            вывод ошибки, как это написано сверху (до блока try-catch).
             */
        }

        /*
        Теперь если мы разделим на ноль, то наша программа не завершится аварийно, а просто
        выведет, что на ноль делить нельзя, и продолжит своё выполнение.
         */

        //Теперь представим следующую ситуацию: мы хотим считать 2 строки, перевести их в число
        //и выполнить деление:
        String a1 = scanner.next();
        String b1 = scanner.next();
        int a2 = Integer.parseInt(a1);
        int b2 = Integer.parseInt(b1);
        System.out.println(a2 / b2);
        /*
        Здесь помимо деления на ноль может возникнуть такая ситуация, что мы передали в
        переменные a1 и b1 не числа, а набор символов, тогда преобразовать эти строки в
        числа будет невозможно, и мы должны обработать ещё одну ошибку, просто добавив
        дополнительный блок catch:
         */
        try {
            int a3 = Integer.parseInt(a1);
            int b3 = Integer.parseInt(b1);
            System.out.println(a3 / b3);
        }
        catch(ArithmeticException ae){
            System.out.println("Нельзя делить на ноль!");
        }
        catch(NumberFormatException nfe){ //тип ошибки неправильного формата числа
            System.out.println("Не удалось перевести строку в число!");
        }

        /*
        Теперь если у нас появится любая из этих ошибок, то мы сможем их обработать.

        Есть способ обработать также все ошибки одновременно. Мы можем вместо конкретного
        класса ошибки в блоке catch написать класс Exception, тогда мы обработаем любую ошибку:
         */

        try {
            int a3 = Integer.parseInt(a1);
            int b3 = Integer.parseInt(b1);
            System.out.println(a3 / b3);
        }
        catch(Exception e){ //класс Exception обрабатывает любую ошибку
            System.out.println("Возникла ошибка!");
        }
        //Однако хорошей практикой считается обработка каждой ошибки отдельно

        /*
        Также у нас может быть блок finally, код внутри которого будет выполнен в любом
        случае, даже если в программе возникла ошибка:
         */

        try {
            int a3 = Integer.parseInt(a1);
            int b3 = Integer.parseInt(b1);
            System.out.println(a3 / b3);
        }
        catch(ArithmeticException ae){
            System.out.println("Нельзя делить на ноль!");
        }
        catch(NumberFormatException nfe){
            System.out.println("Не удалось перевести строку в число!");
        }
        finally {
            System.out.println("Это будет выведено в любом случае!");
            /*
            Код внутри finally выполнится всегда.
            Обычно в блоке finally пишут закрытие всех открытых файлов и т.д.
             */
        }

        /*
        Также можно использовать try-finally без блока catch:
         */

        try {
            int a3 = Integer.parseInt(a1);
            int b3 = Integer.parseInt(b1);
            System.out.println(a3 / b3);
        }
        finally {
            System.out.println("Это будет выведено в любом случае!");
        }
        /*
        Если в блоке try возникнет ошибка, то так как у нас нет блока catch, то
        программа завершится с ошибкой, но перед её завершением отработает блок finally.
    }
}
