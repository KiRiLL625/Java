import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        /*
        Введение в коллекции. Collections Framework содержит в себе
        большое количество разных структур для хранения данных. Одна из
        них - ArrayList - динамический массив, способный увеличивать размеры
        в отличие от стандартных java-массивов. Также в него можно добавлять
        разные данные, однако это считается использованием "сырого" типа.
         */
        ArrayList list = new ArrayList();
        /*
        Сверху мы создали массив (по умолчанию размер вроде бы 10), но при необходимости
        он увеличивается
         */
        list.add(5); //добавляем элементы в массив
        list.add(6);
        list.add(8);
        list.add(9.2);
        list.add("Hello!");
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i)); //выводим элементы (индексы также начинаются с 0)
        }

        /*
        Однако использование сырых типов (когда мы можем что угодно закинуть
        в массив это не очень хорошо, и это редко где используется. Рассмотрим пример:
         */
        ArrayList list2 = new ArrayList();
        list2.add("Hi");
        list2.add("Hello");
        list2.add("Привет");
        list2.add(1);
        for (int i = 0; i < list2.size(); i++) {
            String current = (String) list2.get(i);
            /*
            Если мы хотим полученные данные записать в строку, то мы должны
            их обязательно привести к String, так как фактически мы закидываем
            туда объекты класса Object
             */
            System.out.println(current.length()); //выводим длину строки
        }
        /*
        Но что если какой-то не очень хороший человек добавит не строку, а число
        в наш список? У числа ведь нет метода length(), да и его к строке привести нельзя.
        Тогда программа выбросит ошибку преобразования типов, а тестировщик скажет, что
        это у вас ошибка, а оказывается, что кто-то добавил в список число, а не строку.

        Дженерики от этого защищают. Дженерики - эо такие "подтипы", которые указывают,
        что наш текущий код работает только с типом данных, написанным в угловых скобках.
         */

        ArrayList<String> list3 = new ArrayList<>();
        /*
        Слева указываем, что мы используем только строки, справа нужно поставить
        две угловые скобки - это означает, что мы создаём дженерик-объект. Называется
        это diamond-синтаксис. В более старых версиях во вторых угловых скобках также
        надо было указывать тип хранящегося объекта, но теперь эти скобки можно оставить пустыми.
         */
        list3.add("Hello");
        list3.add("Hi");
        list3.add("Привет");
        //Если мы попробуем добавить не строку, то компилятор нам не даст этого сделать
        for (int i = 0; i < list3.size(); i++) {
            String current = list3.get(i); //даже преобразовывать к String не нужно
        }
        //Создаём объект Box, а тип T делаем String:
        Box<String> box1 = new Box<>();
        box1.things = "Pants"; //теперь переменная things является типом String
        System.out.println(box1.getThings()); //выводим things
        //Создаём объект Box, а тип T делаем Integer:
        Box<Integer> box2 = new Box<>();
        box2.things = 3; //теперь things - это целое число
        System.out.println(box2.getThings()); //выводим целое число

        /*
        Есть небольшой нюанс - дженерики не могут использовать примитивные типы.
        Вместо примитивных типов используются классы-обёртки. Эти классы позволяют
        создать объект (как и классы, которые мы сами делаем), а также использовать
        методы, которых нет у примитивных типов. Вот их список (слева примитивный тип,
        справа - обёртка):

        int - Integer
        double - Double
        float - Float
        byte - Byte
        short - Short
        long - Long
        boolean - Boolean
        char - Character
        String - и так не является примитивным типом
         */
    }
}
